<!DOCTYPE html>
<html lang="zh-CN">
<head>
        <meta charset="UTF-8" />
        <title>3D地球 GPX 轨迹动画</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link href="https://unpkg.com/cesium@1.120.0/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
        <style>
            html, body { width:100%; height:100%; margin:0; padding:0; background:#000; }
            #cesiumContainer {
                    position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
                    width:100%; height:100%;
                    margin:0; padding:0; background:#000;
                }
            #controls {
                    position:absolute; top:10px; left:10px; z-index:999;
                    background:rgba(255,255,255,0.92); padding:8px; border-radius:8px;
                    font-family:system-ui, -apple-system, "PingFang SC", "Microsoft YaHei", sans-serif;
                    font-size:14px; display:flex; flex-wrap:wrap; gap:8px; align-items:center;
                    box-shadow:0 2px 12px rgba(0,0,0,.12);
                }
            #progress { width:240px; }
            button, select, input[type="file"], input[type="number"], input[type="text"], input[type="range"] {
                    padding:6px 10px; border:1px solid #d0d0d7; border-radius:6px; background:#fff;
                }
            button.primary { background:#1f6feb; color:#fff; border-color:#1f6feb; }
            button:disabled { opacity:.5; cursor:not-allowed; }
            .muted { color:#666; font-size:12px; }
        </style>
</head>
<body>
<div id="cesiumContainer"></div>

<div id="controls">
        <input type="file" id="file" accept=".gpx" />
        <button id="fit" disabled>适配视图</button>
        <button id="play" class="primary" disabled>播放</button>
        <button id="pause" disabled>暂停</button>
        <button id="stop" disabled>停止</button>

        <label>倍速:
            <select id="speed">
                    <option value="1">1x</option>
                    <option value="1.5">1.5x</option>
                    <option value="2">2x</option>
                    <option value="3">3x</option>
                    <option value="0.5">0.5x</option>
                </select>
        </label>

        <label>基准速度:
            <select id="mps">
                    <option value="1.4">走路 1.4 m/s</option>
                    <option value="3.0">慢跑 3.0 m/s</option>
                    <option value="5.6">骑行 5.6 m/s</option>
                    <option value="15" selected>驾车 15 m/s</option>
                    <option value="1500">飞机</option>
                </select>
        </label>

        <label>跟随:
            <select id="followMode">
                    <option value="lead" selected>靠前可视</option>
                    <option value="center">居中</option>
                    <option value="off">关闭</option>
                </select>
        </label>

        <label id="leadWrap">前置距离:
            <input type="number" id="leadMeters" value="1200" min="100" max="20000" step="50" /> m
        </label>

        <label>比例:
            <select id="aspectRatio">
                    <option value="default">默认</option>
                    <option value="16:9">16:9</option>
                    <option value="9:16" selected>9:16</option>
                </select>
        </label>

        <label>图标:
            <input type="file" id="markerIcon" accept="image/*" />
        </label>
        <label>交通工具:
            <select id="emojiSelector">
                    <option value="🚗">🚗 汽车</option>
                    <option value="🚢">🚢 轮船</option>
                    <option value="🚚">🚚 卡车</option>
                    <option value="🚆">🚆 火车</option>
                    <option value="✈️">✈️ 飞机</option>
                    <option value="🎈">🎈 热气球</option>
                    <option value="🚲">🚲 自行车</option>
                    <option value="🛵">🛵 摩托车</option>
                    <option value="🛹">🛹 滑板车</option>
                </select>
        </label>
        <label>相机高度:
            <input type="range" id="cameraHeight" min="20" max="500" value="100" step="10" />
            <span id="heightLabel" class="muted">100 m</span>
        </label>

        <input type="range" id="progress" min="0" max="1" step="0.0001" value="0" disabled />
        <span id="pct" class="muted">0%</span>
        <span id="dist" class="muted">0 / 0 km</span>
</div>

<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script src="https://unpkg.com/cesium@1.120.0/Build/Cesium/Cesium.js"></script>
<script>
    // Cesium 初始化
    const viewer = new Cesium.Viewer("cesiumContainer", {
        animation: false, timeline: false, geocoder: false, homeButton: false,
        baseLayerPicker: true, sceneModePicker: true, navigationHelpButton: false, infoBox: false
    });
    viewer.scene.globe.depthTestAgainstTerrain = false;

    // 轨迹与动画状态
    let trackLatLngs = [];  // [[lat, lon], ...]
    let cumDist = [];       // 累积距离（米）
    let totalDist = 0;
    let currentDist = 0;
    let playing = false;
    let lastTs = null;
    let animReq = null;

    // 实体
    let fullLineEntity = null;    // 全轨迹灰色
    let walkedLineEntity = null;  // 已走红色
    let markerEntity = null;      // 小点/图标

    // 范围
    let bounds = null; // {minLat, minLon, maxLat, maxLon}

    // 自定义图标和文字
    let customMarkerUrl = null;
    let markerText = '🚗';

    // 新增函数：根据文字或图片生成 billboard 图片
    function createBillboardImage(text, imageUrl) {
        if (imageUrl) {
            return imageUrl;
        }

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const fontSize = 36;

        ctx.font = `${fontSize}px sans-serif`;
        const textMetrics = ctx.measureText(text);
        const textWidth = textMetrics.width;

        canvas.width = textWidth + 10;
        canvas.height = fontSize + 10;

        ctx.font = `${fontSize}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);

        return canvas.toDataURL();
    }

    // 工具：解析 GPX
    function parseGPXToLatLngs(gpxText) {
        const doc = new DOMParser().parseFromString(gpxText, "application/xml");
        let pts = Array.from(doc.querySelectorAll("trkpt"));
        if (pts.length === 0) pts = Array.from(doc.querySelectorAll("rtept"));
        return pts.map(pt => [parseFloat(pt.getAttribute("lat")), parseFloat(pt.getAttribute("lon"))])
            .filter(v => Number.isFinite(v[0]) && Number.isFinite(v[1]));
    }

    // 工具：球面距离（米）
    function haversineMeters(a, b) {
        const R = 6371000;
        const dLat = (b[0]-a[0]) * Math.PI/180;
        const dLon = (b[1]-a[1]) * Math.PI/180;
        const lat1 = a[0] * Math.PI/180;
        const lat2 = b[0] * Math.PI/180;
        const h = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
        return 2 * R * Math.asin(Math.sqrt(h));
    }

    // 工具：bearing 度
    function bearingDeg(a, b) {
        const φ1 = a[0]*Math.PI/180, φ2 = b[0]*Math.PI/180, λ1 = a[1]*Math.PI/180, λ2 = b[1]*Math.PI/180;
        const y = Math.sin(λ2-λ1) * Math.cos(φ2);
        const x = Math.cos(φ1)*Math.cos(φ2)*Math.cos(λ2-λ1) + Math.sin(φ1)*Math.sin(φ2);
        let deg = Math.atan2(y, x) * 180/Math.PI;
        return (deg + 360) % 360;
    }

    // 工具：朝向与距离得到终点
    function destinationPoint(start, brgDeg, distMeters) {
        const R = 6371000;
        const δ = distMeters / R;
        const θ = brgDeg * Math.PI/180;
        const φ1 = start[0]*Math.PI/180, λ1 = start[1]*Math.PI/180;
        const sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1);
        const sinδ = Math.sin(δ), cosδ = Math.cos(δ);
        const sinφ2 = sinφ1*cosδ + cosφ1*sinδ*Math.cos(θ);
        const φ2 = Math.asin(sinφ2);
        const y = Math.sin(θ)*sinδ*cosφ1;
        const x = cosδ - sinφ1*sinφ2;
        const λ2 = λ1 + Math.atan2(y, x);
        return [φ2*180/Math.PI, ((λ2*180/Math.PI + 540) % 360) - 180];
    }

    // 插值：给定距离，返回 [lat, lon]
    function interpolateAtDistance(d) {
        if (trackLatLngs.length === 0) return null;
        if (d <= 0) return trackLatLngs[0];
        if (d >= totalDist) return trackLatLngs[trackLatLngs.length - 1];

        let lo = 0, hi = cumDist.length - 1;
        while (lo < hi) {
            const mid = (lo + hi) >> 1;
            if (cumDist[mid] < d) lo = mid + 1; else hi = mid;
        }
        const i = Math.max(1, lo);
        const d0 = cumDist[i - 1], d1 = cumDist[i];
        const t = (d - d0) / (d1 - d0);
        const p0 = trackLatLngs[i - 1], p1 = trackLatLngs[i];
        return [p0[0] + (p1[0]-p0[0]) * t, p0[1] + (p1[1]-p0[1]) * t];
    }

    // 当前前进方向用于“靠前可视”
    function currentBearing(pos) {
        if (trackLatLngs.length < 2) return 0;
        let lo = 0, hi = cumDist.length - 1;
        while (lo < hi) {
            const mid = (lo + hi) >> 1;
            if (cumDist[mid] < currentDist) lo = mid + 1; else hi = mid;
        }
        const i = Math.max(1, lo);
        const p1 = trackLatLngs[Math.min(i, trackLatLngs.length - 1)];
        const ref = (currentDist >= totalDist) ? trackLatLngs[trackLatLngs.length - 2] : pos;
        return bearingDeg(ref, p1);
    }

    // UI 更新
    function updateProgressUI() {
        const ratio = totalDist ? currentDist / totalDist : 0;
        $("#progress").val(ratio);
        $("#pct").text((ratio*100).toFixed(1) + "%");
        $("#dist").text((currentDist/1000).toFixed(2) + " / " + (totalDist/1000).toFixed(2) + " km");
    }

    // 更新已走红线 positions
    function updateWalkedLine() {
        if (!walkedLineEntity) return;
        const walkedPoints = [];
        for (let i = 0; i < trackLatLngs.length; i++) {
            if (cumDist[i] <= currentDist) {
                walkedPoints.push(trackLatLngs[i]);
            } else {
                walkedPoints.push(interpolateAtDistance(currentDist));
                break;
            }
        }
        const degArr = walkedPoints.flatMap(([lat, lon]) => [lon, lat]); // Cesium: lon, lat
        walkedLineEntity.polyline.positions = Cesium.Cartesian3.fromDegreesArray(degArr);
    }

    // 相机跟随
    function applyFollowCamera(pos) {
        const mode = $("#followMode").val();
        if (mode === "off") return;

        const brg = currentBearing(pos);

        let target = pos;
        if (mode === "lead") {
            const lead = Math.max(50, Math.min(20000, parseFloat($("#leadMeters").val() || "1200")));
            target = destinationPoint(pos, brg, lead);
        }

        const cameraHeight = parseFloat($("#cameraHeight").val());
        const cameraDistance = cameraHeight / Math.tan(Cesium.Math.toRadians(25)); // 基于高度和俯角计算距离
        const cameraPos = destinationPoint(pos, (brg + 180) % 360, cameraDistance);

        viewer.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(cameraPos[1], cameraPos[0], cameraHeight),
            orientation: {
                heading: Cesium.Math.toRadians(brg),
                pitch: Cesium.Math.toRadians(-25),
                roll: 0.0
            }
        });
    }

    // 设置/重置轨迹
    function setupTrack(latlngs) {
        trackLatLngs = latlngs.slice();
        cumDist = [0]; totalDist = 0;

        for (let i = 1; i < trackLatLngs.length; i++) {
            totalDist += haversineMeters(trackLatLngs[i-1], trackLatLngs[i]);
            cumDist.push(totalDist);
        }

        // bounds
        let minLat = 90, minLon = 180, maxLat = -90, maxLon = -180;
        trackLatLngs.forEach(([lat, lon]) => {
            if (lat < minLat) minLat = lat;
            if (lon < minLon) minLon = lon;
            if (lat > maxLat) maxLat = lat;
            if (lon > maxLon) maxLon = lon;
        });
        bounds = { minLat, minLon, maxLat, maxLon };

        // 清理旧实体
        if (fullLineEntity) viewer.entities.remove(fullLineEntity);
        if (walkedLineEntity) viewer.entities.remove(walkedLineEntity);
        if (markerEntity) viewer.entities.remove(markerEntity);

        // 新建全轨迹（灰）
        fullLineEntity = viewer.entities.add({
            polyline: {
                positions: Cesium.Cartesian3.fromDegreesArray(trackLatLngs.flatMap(([lat, lon]) => [lon, lat])),
                width: 3,
                material: Cesium.Color.fromCssColorString("#888").withAlpha(0.7),
                clampToGround: false
            }
        });

        // 已走（红）
        walkedLineEntity = viewer.entities.add({
            polyline: {
                positions: Cesium.Cartesian3.fromDegreesArray([]),
                width: 4,
                material: Cesium.Color.RED.withAlpha(0.95),
                clampToGround: false
            }
        });

        // 标记
        markerEntity = viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(trackLatLngs[0][1], trackLatLngs[0][0], 0),
            billboard: {
                image: new Cesium.CallbackProperty(() => createBillboardImage(markerText, customMarkerUrl), false),
                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                disableDepthTestDistance: 1000
            }
        });

        currentDist = 0; lastTs = null;
        updateProgressUI();

        $("#play,#stop,#fit,#progress").prop("disabled", trackLatLngs.length < 2);
        $("#pause").prop("disabled", true);
    }

    // 动画帧
    function tick(ts) {
        if (!playing) return;
        if (lastTs == null) lastTs = ts;
        const deltaSec = (ts - lastTs) / 1000;
        lastTs = ts;

        const base = parseFloat($("#mps").val());
        const factor = parseFloat($("#speed").val());
        currentDist += base * factor * deltaSec;

        if (currentDist >= totalDist) {
            currentDist = totalDist;
            playing = false;
        }

        const pos = interpolateAtDistance(currentDist);
        if (pos) {
            markerEntity.position = Cesium.Cartesian3.fromDegrees(pos[1], pos[0], 0);
            updateWalkedLine();
            applyFollowCamera(pos);
        }
        updateProgressUI();

        if (playing) animReq = requestAnimationFrame(tick);
        else {
            cancelAnimationFrame(animReq);
            animReq = null;
            $("#play").prop("disabled", false).text("重播").addClass("primary");
            $("#pause").prop("disabled", true);
        }
    }

    // 适配视域到轨迹
    function fitToBounds() {
        if (!bounds) return;
        const rect = Cesium.Rectangle.fromDegrees(bounds.minLon, bounds.minLat, bounds.maxLon, bounds.maxLat);
        viewer.camera.flyTo({ destination: rect });
    }

    // 根据选择的比例调整地图容器尺寸
    function handleAspectRatioChange() {
        const ratio = $("#aspectRatio").val();
        const container = $("#cesiumContainer");
        const windowWidth = $(window).width();
        const windowHeight = $(window).height();

        if (ratio === "default") {
            container.css({ width: "100%", height: "100%" });
        } else {
            const [ratioWidth, ratioHeight] = ratio.split(":").map(Number);
            const windowRatio = windowWidth / windowHeight;
            const targetRatio = ratioWidth / ratioHeight;

            let newWidth, newHeight;
            if (windowRatio > targetRatio) {
                newHeight = windowHeight;
                newWidth = newHeight * targetRatio;
            } else {
                newWidth = windowWidth;
                newHeight = newWidth / targetRatio;
            }
            container.css({ width: newWidth + "px", height: newHeight + "px" });
        }
        viewer.resize();
    }

    // 事件绑定
    $(function(){
        viewer.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(139.0, 35.0, 2_000_000)
        });

        handleAspectRatioChange();
        $(window).on("resize", handleAspectRatioChange);
        $("#aspectRatio").on("change", handleAspectRatioChange);

        $("#file").on("change", function(e){
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(evt){
                const gpxText = evt.target.result;
                const latlngs = parseGPXToLatLngs(gpxText);
                if (!latlngs || latlngs.length < 2) {
                    alert("未解析到有效轨迹点（trkpt/rtept）");
                    return;
                }
                setupTrack(latlngs);
                fitToBounds();
                $("#fit").prop("disabled", false);
            };
            reader.readAsText(file);
        });

        $("#play").on("click", function(){
            if (totalDist <= 0) return;
            playing = true; lastTs = null;
            $("#pause").prop("disabled", false);
            $(this).removeClass("primary").text("播放");
            animReq = requestAnimationFrame(tick);
        });

        $("#pause").on("click", function(){
            playing = false;
            cancelAnimationFrame(animReq);
            $(this).prop("disabled", true);
            $("#play").prop("disabled", false).addClass("primary").text("继续");
        });

        $("#stop").on("click", function(){
            playing = false;
            cancelAnimationFrame(animReq);
            currentDist = 0;
            updateProgressUI();
            if (markerEntity && trackLatLngs.length) {
                const p = trackLatLngs[0];
                markerEntity.position = Cesium.Cartesian3.fromDegrees(p[1], p[0], 0);
            }
            updateWalkedLine();
            $("#pause").prop("disabled", true);
            $("#play").prop("disabled", false).addClass("primary").text("播放");
        });

        $("#fit").on("click", fitToBounds);

        $("#progress").on("input", function(){
            if (totalDist <= 0) return;
            const ratio = parseFloat($(this).val());
            currentDist = Math.max(0, Math.min(1, ratio)) * totalDist;
            const pos = interpolateAtDistance(currentDist);
            if (pos && markerEntity) {
                markerEntity.position = Cesium.Cartesian3.fromDegrees(pos[1], pos[0], 0);
                updateWalkedLine();
                applyFollowCamera(pos);
            }
            updateProgressUI();
        });

        $("#followMode").on("change", function(){
            const mode = $(this).val();
            $("#leadWrap").css("display", mode === "lead" ? "inline-flex" : "none");
        }).trigger("change");

        // 处理图标文件上传
        $("#markerIcon").on("change", function(e) {
            const file = e.target.files[0];
            if (!file) {
                customMarkerUrl = null;
                return;
            }
            const reader = new FileReader();
            reader.onload = function(evt) {
                customMarkerUrl = evt.target.result;
                // 清除文字，优先显示图片
                markerText = '';
                $("#emojiSelector").val('');
            };
            reader.readAsDataURL(file);
        });

        // 处理交通工具选择
        $("#emojiSelector").on("change", function() {
            markerText = $(this).val();
            customMarkerUrl = null; // 清除图片，优先显示文字
            $("#markerIcon").val('');
        });

        // 处理相机高度调整
        $("#cameraHeight").on("input", function() {
            $("#heightLabel").text($(this).val() + " m");
        });
    });
</script>
</body>
</html>