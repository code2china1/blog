<!DOCTYPE html>
<html lang="zh-CN">
<head>
    Â  Â  <meta charset="UTF-8" />
    Â  Â  <title>3Dåœ°çƒ GPX è½¨è¿¹åŠ¨ç”»</title>
    Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1" />
    Â  Â  <link href="https://unpkg.com/cesium@1.120.0/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
    Â  Â  <style>
    Â  Â  Â  Â  html, body { width:100%; height:100%; margin:0; padding:0; background:#000; }
    Â  Â  Â  Â  #cesiumContainer {
        Â  Â  Â  Â  Â  Â  position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
        Â  Â  Â  Â  Â  Â  width:100%; height:100%;
        Â  Â  Â  Â  Â  Â  margin:0; padding:0; background:#000;
        Â  Â  Â  Â  }
    Â  Â  Â  Â  #controls {
        Â  Â  Â  Â  Â  Â  position:absolute; top:10px; left:10px; z-index:999;
        Â  Â  Â  Â  Â  Â  background:rgba(255,255,255,0.92); padding:8px; border-radius:8px;
        Â  Â  Â  Â  Â  Â  font-family:system-ui, -apple-system, "PingFang SC", "Microsoft YaHei", sans-serif;
        Â  Â  Â  Â  Â  Â  font-size:14px; display:flex; flex-wrap:wrap; gap:8px; align-items:center;
        Â  Â  Â  Â  Â  Â  box-shadow:0 2px 12px rgba(0,0,0,.12);
        Â  Â  Â  Â  }
    Â  Â  Â  Â  #progress { width:240px; }
    Â  Â  Â  Â  button, select, input[type="file"], input[type="number"], input[type="text"], input[type="range"] {
        Â  Â  Â  Â  Â  Â  padding:6px 10px; border:1px solid #d0d0d7; border-radius:6px; background:#fff;
        Â  Â  Â  Â  }
    Â  Â  Â  Â  button.primary { background:#1f6feb; color:#fff; border-color:#1f6feb; }
    Â  Â  Â  Â  button:disabled { opacity:.5; cursor:not-allowed; }
    Â  Â  Â  Â  .muted { color:#666; font-size:12px; }
    Â  Â  </style>
</head>
<body>
<div id="cesiumContainer"></div>

<div id="controls">
    Â  Â  <input type="file" id="file" accept=".gpx" />
    Â  Â  <button id="fit" disabled>é€‚é…è§†å›¾</button>
    Â  Â  <button id="play" class="primary" disabled>æ’­æ”¾</button>
    Â  Â  <button id="pause" disabled>æš‚åœ</button>
    Â  Â  <button id="stop" disabled>åœæ­¢</button>

    Â  Â  <label>å€é€Ÿ:
    Â  Â  Â  Â  <select id="speed">
        Â  Â  Â  Â  Â  Â  <option value="1">1x</option>
        Â  Â  Â  Â  Â  Â  <option value="1.5">1.5x</option>
        Â  Â  Â  Â  Â  Â  <option value="2">2x</option>
        Â  Â  Â  Â  Â  Â  <option value="3">3x</option>
        Â  Â  Â  Â  Â  Â  <option value="0.5">0.5x</option>
        Â  Â  Â  Â  </select>
    Â  Â  </label>

    Â  Â  <label>åŸºå‡†é€Ÿåº¦:
    Â  Â  Â  Â  <select id="mps">
        Â  Â  Â  Â  Â  Â  <option value="1.4">èµ°è·¯ 1.4 m/s</option>
        Â  Â  Â  Â  Â  Â  <option value="3.0">æ…¢è·‘ 3.0 m/s</option>
        Â  Â  Â  Â  Â  Â  <option value="5.6">éª‘è¡Œ 5.6 m/s</option>
        Â  Â  Â  Â  Â  Â  <option value="15" selected>é©¾è½¦ 15 m/s</option>
        Â  Â  Â  Â  Â  Â  <option value="1500">é£æœº</option>
        Â  Â  Â  Â  </select>
    Â  Â  </label>

    Â  Â  <label>è·Ÿéš:
    Â  Â  Â  Â  <select id="followMode">
        Â  Â  Â  Â  Â  Â  <option value="lead" selected>é å‰å¯è§†</option>
        Â  Â  Â  Â  Â  Â  <option value="center">å±…ä¸­</option>
        Â  Â  Â  Â  Â  Â  <option value="off">å…³é—­</option>
        Â  Â  Â  Â  </select>
    Â  Â  </label>

    Â  Â  <label id="leadWrap">å‰ç½®è·ç¦»:
    Â  Â  Â  Â  <input type="number" id="leadMeters" value="1200" min="100" max="20000" step="50" /> m
    Â  Â  </label>

    Â  Â  <label>æ¯”ä¾‹:
    Â  Â  Â  Â  <select id="aspectRatio">
        Â  Â  Â  Â  Â  Â  <option value="default">é»˜è®¤</option>
        Â  Â  Â  Â  Â  Â  <option value="16:9">16:9</option>
        Â  Â  Â  Â  Â  Â  <option value="9:16" selected>9:16</option>
        Â  Â  Â  Â  </select>
    Â  Â  </label>

    Â  Â  <label>å›¾æ ‡:
    Â  Â  Â  Â  <input type="file" id="markerIcon" accept="image/*" />
    Â  Â  </label>
    Â  Â  <label>äº¤é€šå·¥å…·:
    Â  Â  Â  Â  <select id="emojiSelector">
        Â  Â  Â  Â  Â  Â  <option value="ğŸš—">ğŸš— æ±½è½¦</option>
        Â  Â  Â  Â  Â  Â  <option value="ğŸš¢">ğŸš¢ è½®èˆ¹</option>
        Â  Â  Â  Â  Â  Â  <option value="ğŸšš">ğŸšš å¡è½¦</option>
        Â  Â  Â  Â  Â  Â  <option value="ğŸš†">ğŸš† ç«è½¦</option>
        Â  Â  Â  Â  Â  Â  <option value="âœˆï¸">âœˆï¸ é£æœº</option>
        Â  Â  Â  Â  Â  Â  <option value="ğŸˆ">ğŸˆ çƒ­æ°”çƒ</option>
        Â  Â  Â  Â  Â  Â  <option value="ğŸš²">ğŸš² è‡ªè¡Œè½¦</option>
        Â  Â  Â  Â  Â  Â  <option value="ğŸ›µ">ğŸ›µ æ‘©æ‰˜è½¦</option>
        Â  Â  Â  Â  Â  Â  <option value="ğŸ›¹">ğŸ›¹ æ»‘æ¿è½¦</option>
        Â  Â  Â  Â  </select>
    Â  Â  </label>
    Â  Â  <label>ç›¸æœºé«˜åº¦:
    Â  Â  Â  Â  <input type="range" id="cameraHeight" min="20" max="500" value="100" step="10" />
    Â  Â  Â  Â  <span id="heightLabel" class="muted">100 m</span>
    Â  Â  </label>

    Â  Â  <input type="range" id="progress" min="0" max="1" step="0.0001" value="0" disabled />
    Â  Â  <span id="pct" class="muted">0%</span>
    Â  Â  <span id="dist" class="muted">0 / 0 km</span>
</div>

<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script src="https://unpkg.com/cesium@1.120.0/Build/Cesium/Cesium.js"></script>
<script>
    // Cesium åˆå§‹åŒ–
    const viewer = new Cesium.Viewer("cesiumContainer", {
        animation: false, timeline: false, geocoder: false, homeButton: false,
        baseLayerPicker: true, sceneModePicker: true, navigationHelpButton: false, infoBox: false
    });
    viewer.scene.globe.depthTestAgainstTerrain = false;

    // è½¨è¿¹ä¸åŠ¨ç”»çŠ¶æ€
    let trackLatLngs = [];Â  // [[lat, lon], ...]
    let cumDist = [];Â  Â  Â  Â // ç´¯ç§¯è·ç¦»ï¼ˆç±³ï¼‰
    let totalDist = 0;
    let currentDist = 0;
    let playing = false;
    let lastTs = null;
    let animReq = null;

    // å®ä½“
    let fullLineEntity = null;Â  Â  // å…¨è½¨è¿¹ç°è‰²
    let walkedLineEntity = null;Â  // å·²èµ°çº¢è‰²
    let markerEntity = null;Â  Â  Â  // å°ç‚¹/å›¾æ ‡

    // èŒƒå›´
    let bounds = null; // {minLat, minLon, maxLat, maxLon}

    // è‡ªå®šä¹‰å›¾æ ‡å’Œæ–‡å­—
    let customMarkerUrl = null;
    let markerText = 'ğŸš—';

    // æ–°å¢å‡½æ•°ï¼šæ ¹æ®æ–‡å­—æˆ–å›¾ç‰‡ç”Ÿæˆ billboard å›¾ç‰‡
    function createBillboardImage(text, imageUrl) {
        if (imageUrl) {
            return imageUrl;
        }

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const fontSize = 36;

        ctx.font = `${fontSize}px sans-serif`;
        const textMetrics = ctx.measureText(text);
        const textWidth = textMetrics.width;

        canvas.width = textWidth + 10;
        canvas.height = fontSize + 10;

        ctx.font = `${fontSize}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);

        return canvas.toDataURL();
    }

    // å·¥å…·ï¼šè§£æ GPX
    function parseGPXToLatLngs(gpxText) {
        const doc = new DOMParser().parseFromString(gpxText, "application/xml");
        let pts = Array.from(doc.querySelectorAll("trkpt"));
        if (pts.length === 0) pts = Array.from(doc.querySelectorAll("rtept"));
        return pts.map(pt => [parseFloat(pt.getAttribute("lat")), parseFloat(pt.getAttribute("lon"))])
            .filter(v => Number.isFinite(v[0]) && Number.isFinite(v[1]));
    }

    // å·¥å…·ï¼šçƒé¢è·ç¦»ï¼ˆç±³ï¼‰
    function haversineMeters(a, b) {
        const R = 6371000;
        const dLat = (b[0]-a[0]) * Math.PI/180;
        const dLon = (b[1]-a[1]) * Math.PI/180;
        const lat1 = a[0] * Math.PI/180;
        const lat2 = b[0] * Math.PI/180;
        const h = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
        return 2 * R * Math.asin(Math.sqrt(h));
    }

    // å·¥å…·ï¼šbearing åº¦
    function bearingDeg(a, b) {
        const Ï†1 = a[0]*Math.PI/180, Ï†2 = b[0]*Math.PI/180, Î»1 = a[1]*Math.PI/180, Î»2 = b[1]*Math.PI/180;
        const y = Math.sin(Î»2-Î»1) * Math.cos(Ï†2);
        const x = Math.cos(Ï†1)*Math.cos(Ï†2)*Math.cos(Î»2-Î»1) + Math.sin(Ï†1)*Math.sin(Ï†2);
        let deg = Math.atan2(y, x) * 180/Math.PI;
        return (deg + 360) % 360;
    }

    // å·¥å…·ï¼šæœå‘ä¸è·ç¦»å¾—åˆ°ç»ˆç‚¹
    function destinationPoint(start, brgDeg, distMeters) {
        const R = 6371000;
        const Î´ = distMeters / R;
        const Î¸ = brgDeg * Math.PI/180;
        const Ï†1 = start[0]*Math.PI/180, Î»1 = start[1]*Math.PI/180;
        const sinÏ†1 = Math.sin(Ï†1), cosÏ†1 = Math.cos(Ï†1);
        const sinÎ´ = Math.sin(Î´), cosÎ´ = Math.cos(Î´);
        const sinÏ†2 = sinÏ†1*cosÎ´ + cosÏ†1*sinÎ´*Math.cos(Î¸);
        const Ï†2 = Math.asin(sinÏ†2);
        const y = Math.sin(Î¸)*sinÎ´*cosÏ†1;
        const x = cosÎ´ - sinÏ†1*sinÏ†2;
        const Î»2 = Î»1 + Math.atan2(y, x);
        return [Ï†2*180/Math.PI, ((Î»2*180/Math.PI + 540) % 360) - 180];
    }

    // æ’å€¼ï¼šç»™å®šè·ç¦»ï¼Œè¿”å› [lat, lon]
    function interpolateAtDistance(d) {
        if (trackLatLngs.length === 0) return null;
        if (d <= 0) return trackLatLngs[0];
        if (d >= totalDist) return trackLatLngs[trackLatLngs.length - 1];

        let lo = 0, hi = cumDist.length - 1;
        while (lo < hi) {
            const mid = (lo + hi) >> 1;
            if (cumDist[mid] < d) lo = mid + 1; else hi = mid;
        }
        const i = Math.max(1, lo);
        const d0 = cumDist[i - 1], d1 = cumDist[i];
        const t = (d - d0) / (d1 - d0);
        const p0 = trackLatLngs[i - 1], p1 = trackLatLngs[i];
        return [p0[0] + (p1[0]-p0[0]) * t, p0[1] + (p1[1]-p0[1]) * t];
    }

    // å½“å‰å‰è¿›æ–¹å‘ç”¨äºâ€œé å‰å¯è§†â€
    function currentBearing(pos) {
        if (trackLatLngs.length < 2) return 0;
        let lo = 0, hi = cumDist.length - 1;
        while (lo < hi) {
            const mid = (lo + hi) >> 1;
            if (cumDist[mid] < currentDist) lo = mid + 1; else hi = mid;
        }
        const i = Math.max(1, lo);
        const p1 = trackLatLngs[Math.min(i, trackLatLngs.length - 1)];
        const ref = (currentDist >= totalDist) ? trackLatLngs[trackLatLngs.length - 2] : pos;
        return bearingDeg(ref, p1);
    }

    // UI æ›´æ–°
    function updateProgressUI() {
        const ratio = totalDist ? currentDist / totalDist : 0;
        $("#progress").val(ratio);
        $("#pct").text((ratio*100).toFixed(1) + "%");
        $("#dist").text((currentDist/1000).toFixed(2) + " / " + (totalDist/1000).toFixed(2) + " km");
    }

    // æ›´æ–°å·²èµ°çº¢çº¿ positions
    function updateWalkedLine() {
        if (!walkedLineEntity) return;
        const walkedPoints = [];
        for (let i = 0; i < trackLatLngs.length; i++) {
            if (cumDist[i] <= currentDist) {
                walkedPoints.push(trackLatLngs[i]);
            } else {
                walkedPoints.push(interpolateAtDistance(currentDist));
                break;
            }
        }
        const degArr = walkedPoints.flatMap(([lat, lon]) => [lon, lat]); // Cesium: lon, lat
        walkedLineEntity.polyline.positions = Cesium.Cartesian3.fromDegreesArray(degArr);
    }

    // ç›¸æœºè·Ÿéš
    function applyFollowCamera(pos) {
        const mode = $("#followMode").val();
        if (mode === "off") return;

        const brg = currentBearing(pos);

        let target = pos;
        if (mode === "lead") {
            const lead = Math.max(50, Math.min(20000, parseFloat($("#leadMeters").val() || "1200")));
            target = destinationPoint(pos, brg, lead);
        }

        const cameraHeight = parseFloat($("#cameraHeight").val());
        const cameraDistance = cameraHeight / Math.tan(Cesium.Math.toRadians(25)); // åŸºäºé«˜åº¦å’Œä¿¯è§’è®¡ç®—è·ç¦»
        const cameraPos = destinationPoint(pos, (brg + 180) % 360, cameraDistance);

        viewer.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(cameraPos[1], cameraPos[0], cameraHeight),
            orientation: {
                heading: Cesium.Math.toRadians(brg),
                pitch: Cesium.Math.toRadians(-25),
                roll: 0.0
            }
        });
    }

    // è®¾ç½®/é‡ç½®è½¨è¿¹
    function setupTrack(latlngs) {
        trackLatLngs = latlngs.slice();
        cumDist = [0]; totalDist = 0;

        for (let i = 1; i < trackLatLngs.length; i++) {
            totalDist += haversineMeters(trackLatLngs[i-1], trackLatLngs[i]);
            cumDist.push(totalDist);
        }

        // bounds
        let minLat = 90, minLon = 180, maxLat = -90, maxLon = -180;
        trackLatLngs.forEach(([lat, lon]) => {
            if (lat < minLat) minLat = lat;
            if (lon < minLon) minLon = lon;
            if (lat > maxLat) maxLat = lat;
            if (lon > maxLon) maxLon = lon;
        });
        bounds = { minLat, minLon, maxLat, maxLon };

        // æ¸…ç†æ—§å®ä½“
        if (fullLineEntity) viewer.entities.remove(fullLineEntity);
        if (walkedLineEntity) viewer.entities.remove(walkedLineEntity);
        if (markerEntity) viewer.entities.remove(markerEntity);

        // æ–°å»ºå…¨è½¨è¿¹ï¼ˆç°ï¼‰
        fullLineEntity = viewer.entities.add({
            polyline: {
                positions: Cesium.Cartesian3.fromDegreesArray(trackLatLngs.flatMap(([lat, lon]) => [lon, lat])),
                width: 3,
                material: Cesium.Color.fromCssColorString("#888").withAlpha(0.7),
                clampToGround: false
            }
        });

        // å·²èµ°ï¼ˆçº¢ï¼‰
        walkedLineEntity = viewer.entities.add({
            polyline: {
                positions: Cesium.Cartesian3.fromDegreesArray([]),
                width: 4,
                material: Cesium.Color.RED.withAlpha(0.95),
                clampToGround: false
            }
        });

        // æ ‡è®°
        markerEntity = viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(trackLatLngs[0][1], trackLatLngs[0][0], 0),
            billboard: {
                image: new Cesium.CallbackProperty(() => createBillboardImage(markerText, customMarkerUrl), false),
                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                disableDepthTestDistance: 1000
            }
        });

        currentDist = 0; lastTs = null;
        updateProgressUI();

        $("#play,#stop,#fit,#progress").prop("disabled", trackLatLngs.length < 2);
        $("#pause").prop("disabled", true);
    }

    // åŠ¨ç”»å¸§
    function tick(ts) {
        if (!playing) return;
        if (lastTs == null) lastTs = ts;
        const deltaSec = (ts - lastTs) / 1000;
        lastTs = ts;

        const base = parseFloat($("#mps").val());
        const factor = parseFloat($("#speed").val());
        currentDist += base * factor * deltaSec;

        if (currentDist >= totalDist) {
            currentDist = totalDist;
            playing = false;
        }

        const pos = interpolateAtDistance(currentDist);
        if (pos) {
            markerEntity.position = Cesium.Cartesian3.fromDegrees(pos[1], pos[0], 0);
            updateWalkedLine();
            applyFollowCamera(pos);
        }
        updateProgressUI();

        if (playing) animReq = requestAnimationFrame(tick);
        else {
            cancelAnimationFrame(animReq);
            animReq = null;
            $("#play").prop("disabled", false).text("é‡æ’­").addClass("primary");
            $("#pause").prop("disabled", true);
        }
    }

    // é€‚é…è§†åŸŸåˆ°è½¨è¿¹
    function fitToBounds() {
        if (!bounds) return;
        const rect = Cesium.Rectangle.fromDegrees(bounds.minLon, bounds.minLat, bounds.maxLon, bounds.maxLat);
        viewer.camera.flyTo({ destination: rect });
    }

    // æ ¹æ®é€‰æ‹©çš„æ¯”ä¾‹è°ƒæ•´åœ°å›¾å®¹å™¨å°ºå¯¸
    function handleAspectRatioChange() {
        const ratio = $("#aspectRatio").val();
        const container = $("#cesiumContainer");
        const windowWidth = $(window).width();
        const windowHeight = $(window).height();

        if (ratio === "default") {
            container.css({ width: "100%", height: "100%" });
        } else {
            const [ratioWidth, ratioHeight] = ratio.split(":").map(Number);
            const windowRatio = windowWidth / windowHeight;
            const targetRatio = ratioWidth / ratioHeight;

            let newWidth, newHeight;
            if (windowRatio > targetRatio) {
                newHeight = windowHeight;
                newWidth = newHeight * targetRatio;
            } else {
                newWidth = windowWidth;
                newHeight = newWidth / targetRatio;
            }
            container.css({ width: newWidth + "px", height: newHeight + "px" });
        }
        viewer.resize();
    }

    // äº‹ä»¶ç»‘å®š
    $(function(){
        viewer.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(139.0, 35.0, 2_000_000)
        });

        handleAspectRatioChange();
        $(window).on("resize", handleAspectRatioChange);
        $("#aspectRatio").on("change", handleAspectRatioChange);

        $("#file").on("change", function(e){
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(evt){
                const gpxText = evt.target.result;
                const latlngs = parseGPXToLatLngs(gpxText);
                if (!latlngs || latlngs.length < 2) {
                    alert("æœªè§£æåˆ°æœ‰æ•ˆè½¨è¿¹ç‚¹ï¼ˆtrkpt/rteptï¼‰");
                    return;
                }
                setupTrack(latlngs);
                fitToBounds();
                $("#fit").prop("disabled", false);
            };
            reader.readAsText(file);
        });

        $("#play").on("click", function(){
            if (totalDist <= 0) return;
            playing = true; lastTs = null;
            $("#pause").prop("disabled", false);
            $(this).removeClass("primary").text("æ’­æ”¾");
            animReq = requestAnimationFrame(tick);
        });

        $("#pause").on("click", function(){
            playing = false;
            cancelAnimationFrame(animReq);
            $(this).prop("disabled", true);
            $("#play").prop("disabled", false).addClass("primary").text("ç»§ç»­");
        });

        $("#stop").on("click", function(){
            playing = false;
            cancelAnimationFrame(animReq);
            currentDist = 0;
            updateProgressUI();
            if (markerEntity && trackLatLngs.length) {
                const p = trackLatLngs[0];
                markerEntity.position = Cesium.Cartesian3.fromDegrees(p[1], p[0], 0);
            }
            updateWalkedLine();
            $("#pause").prop("disabled", true);
            $("#play").prop("disabled", false).addClass("primary").text("æ’­æ”¾");
        });

        $("#fit").on("click", fitToBounds);

        $("#progress").on("input", function(){
            if (totalDist <= 0) return;
            const ratio = parseFloat($(this).val());
            currentDist = Math.max(0, Math.min(1, ratio)) * totalDist;
            const pos = interpolateAtDistance(currentDist);
            if (pos && markerEntity) {
                markerEntity.position = Cesium.Cartesian3.fromDegrees(pos[1], pos[0], 0);
                updateWalkedLine();
                applyFollowCamera(pos);
            }
            updateProgressUI();
        });

        $("#followMode").on("change", function(){
            const mode = $(this).val();
            $("#leadWrap").css("display", mode === "lead" ? "inline-flex" : "none");
        }).trigger("change");

        // å¤„ç†å›¾æ ‡æ–‡ä»¶ä¸Šä¼ 
        $("#markerIcon").on("change", function(e) {
            const file = e.target.files[0];
            if (!file) {
                customMarkerUrl = null;
                return;
            }
            const reader = new FileReader();
            reader.onload = function(evt) {
                customMarkerUrl = evt.target.result;
                // æ¸…é™¤æ–‡å­—ï¼Œä¼˜å…ˆæ˜¾ç¤ºå›¾ç‰‡
                markerText = '';
                $("#emojiSelector").val('');
            };
            reader.readAsDataURL(file);
        });

        // å¤„ç†äº¤é€šå·¥å…·é€‰æ‹©
        $("#emojiSelector").on("change", function() {
            markerText = $(this).val();
            customMarkerUrl = null; // æ¸…é™¤å›¾ç‰‡ï¼Œä¼˜å…ˆæ˜¾ç¤ºæ–‡å­—
            $("#markerIcon").val('');
        });

        // å¤„ç†ç›¸æœºé«˜åº¦è°ƒæ•´
        $("#cameraHeight").on("input", function() {
            $("#heightLabel").text($(this).val() + " m");
        });
    });
</script>
</body>
</html>