<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <title>3Dåœ°çƒ GPX è½¨è¿¹åŠ¨ç”»</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="css/widgets.css" rel="stylesheet" />
    <style>
        html, body { width:100%; height:100%; margin:0; padding:0; background:#000; }
        #cesiumContainer {
            position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
            width:100%; height:100%;
            margin:0; padding:0; background:#000;
        }
        #controls {
            position:absolute; top:10px; left:10px; z-index:999;
            background:rgba(255,255,255,0.92); padding:8px; border-radius:8px;
            font-family:system-ui, -apple-system, "PingFang SC", "Microsoft YaHei", sans-serif;
            font-size:14px; display:flex; flex-wrap:wrap; gap:8px; align-items:center;
            box-shadow:0 2px 12px rgba(0,0,0,.12);
        }
        #progress { width:240px; }
        button, select, input[type="file"], input[type="number"], input[type="text"], input[type="range"] {
            padding:6px 10px; border:1px solid #d0d0d7; border-radius:6px; background:#fff;
        }
        button.primary { background:#1f6feb; color:#fff; border-color:#1f6feb; }
        button:disabled { opacity:.5; cursor:not-allowed; }
        .muted { color:#666; font-size:12px; }
        .label-wrap { display:flex; align-items:center; }

        /* New styles for the toggle button */
        #toggle-controls-btn {
            position: absolute;
            top: 10px;
            z-index: 1000; /* Ensure it's on top of other elements */
            background-color: #fff;
            color: #333;
            border: 1px solid #d0d0d7;
            border-radius: 6px;
            padding: 6px 12px;
            cursor: pointer;
            box-shadow: 0 2px 12px rgba(0,0,0,.12);
            font-family: system-ui, -apple-system, "PingFang SC", "Microsoft YaHei", sans-serif;
            font-size: 14px;
        }
    </style>
</head>
<body>
<div id="cesiumContainer"></div>

<div id="controls">
    <input type="file" id="file" accept=".gpx" />
    <button id="fit" disabled>é€‚é…è§†å›¾</button>
    <button id="play" class="primary" disabled>æ’­æ”¾</button>
    <button id="pause" disabled>æš‚åœ</button>
    <button id="stop" disabled>åœæ­¢</button>

    <label>å€é€Ÿ:
        <select id="speed">
            <option value="1">1x</option>
            <option value="1.5">1.5x</option>
            <option value="2">2x</option>
            <option value="3">3x</option>
            <option value="5">5x</option>
            <option value="10">10x</option>
            <option value="0.5">0.5x</option>
        </select>
    </label>

    <label>åŸºå‡†é€Ÿåº¦:
        <select id="mps">
            <option value="1.4">èµ°è·¯ 1.4 m/s</option>
            <option value="3.0">æ…¢è·‘ 3.0 m/s</option>
            <option value="5.6">éª‘è¡Œ 5.6 m/s</option>
            <option value="15" selected>é©¾è½¦ 15 m/s</option>
            <option value="1500">é£æœº</option>
            <option value="15000">ç«ç®­</option>
        </select>
    </label>

    <label>è·Ÿéš:
        <select id="followMode">
            <option value="lead" selected>é å‰å¯è§†</option>
            <option value="center">å±…ä¸­</option>
            <option value="off">å…³é—­</option>
        </select>
    </label>

    <label id="leadWrap">å‰ç½®è·ç¦»:
        <input type="number" id="leadMeters" value="1200" min="100" max="20000" step="50" /> m
    </label>

    <label>æ¯”ä¾‹:
        <select id="aspectRatio">
            <option value="default">é»˜è®¤</option>
            <option value="16:9">16:9</option>
            <option value="9:16" selected>9:16</option>
        </select>
    </label>

    <label>å›¾æ ‡:
        <input type="file" id="markerIcon" accept="image/*" />
    </label>
    <label>äº¤é€šå·¥å…·:
        <select id="emojiSelector">
            <option value="ğŸš—">ğŸš— æ±½è½¦</option>
            <option value="ğŸš¢">ğŸš¢ è½®èˆ¹</option>
            <option value="ğŸšš">ğŸšš å¡è½¦</option>
            <option value="ğŸš†">ğŸš† ç«è½¦</option>
            <option value="âœˆï¸">âœˆï¸ é£æœº</option>
            <option value="ğŸˆ">ğŸˆ çƒ­æ°”çƒ</option>
            <option value="ğŸš²">ğŸš² è‡ªè¡Œè½¦</option>
            <option value="ğŸ›µ">ğŸ›µ æ‘©æ‰˜è½¦</option>
            <option value="ğŸ›¹">ğŸ›¹ æ»‘æ¿è½¦</option>
        </select>
    </label>
    <label>ç›¸æœºé«˜åº¦:
        <input type="range" id="cameraHeight" min="20" max="500" value="100" step="10" />
        <span id="heightLabel" class="muted">100 m</span>
    </label>
    <label>ç›¸æœºä»°è§’:
        <input type="range" id="pitchAngle" min="-90" max="-5" value="-25" step="1" />
        <span id="pitchLabel" class="muted">-25Â°</span>
    </label>
    <label>é«˜ç¨‹æ‹‰ä¼¸:
        <input type="range" id="exaggeration" min="1" max="5000" value="1" step="1" />
        <span id="exaggerationLabel" class="muted">1x</span>
    </label>
    <div class="label-wrap">
        <input type="checkbox" id="showLabel" checked />
        <label for="showLabel">æ˜¾ç¤ºå…¬é‡Œæ•°</label>
    </div>
    <label>å•ä½:
        <select id="unitSelector">
            <option value="km">åƒç±³</option>
            <option value="m">ç±³</option>
        </select>
    </label>

    <input type="range" id="progress" min="0" max="1" step="0.0001" value="0" disabled />
    <span id="pct" class="muted">0%</span>
    <span id="dist" class="muted">0 / 0 km</span>
</div>

<button id="toggle-controls-btn">éšè—æ§åˆ¶é¢æ¿</button>

<script src="js/jquery-3.7.1.min.js"></script>
<script src="js/Cesium.js"></script>
<script>
    // Cesium åˆå§‹åŒ–
    const viewer = new Cesium.Viewer("cesiumContainer", {
        animation: false,
        timeline: false, geocoder: false, homeButton: false,
        baseLayerPicker: true, sceneModePicker: true, navigationHelpButton: false, infoBox: false
    });
    viewer.scene.globe.depthTestAgainstTerrain = false;

    // è½¨è¿¹ä¸åŠ¨ç”»çŠ¶æ€
    let trackLatLngs = [];
    let cumDist = [];
    let totalDist = 0;
    let currentDist = 0;
    let playing = false;
    let lastTs = null;
    let animReq = null;

    // å®ä½“
    let fullLineEntity = null;
    let walkedLineEntity = null;
    let markerEntity = null;
    let distanceLabelEntity = null;

    // èŒƒå›´
    let bounds = null;

    // è‡ªå®šä¹‰å›¾æ ‡å’Œæ–‡å­—
    let customMarkerUrl = null;
    let markerText = 'ğŸš—';

    // æ ¹æ®æ–‡å­—æˆ–å›¾ç‰‡ç”Ÿæˆ billboard å›¾ç‰‡
    function createBillboardImage(text, imageUrl) {
        if (imageUrl) {
            return imageUrl;
        }
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const fontSize = 36;
        ctx.font = `${fontSize}px sans-serif`;
        const textMetrics = ctx.measureText(text);
        const textWidth = textMetrics.width;
        canvas.width = textWidth + 10;
        canvas.height = fontSize + 10;
        ctx.font = `${fontSize}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        return canvas.toDataURL();
    }

    // å·¥å…·ï¼šè§£æ GPX
    function parseGPXToLatLngs(gpxText) {
        const doc = new DOMParser().parseFromString(gpxText, "application/xml");
        let pts = Array.from(doc.querySelectorAll("trkpt"));
        if (pts.length === 0) pts = Array.from(doc.querySelectorAll("rtept"));
        return pts.map(pt => [parseFloat(pt.getAttribute("lat")), parseFloat(pt.getAttribute("lon"))])
            .filter(v => Number.isFinite(v[0]) && Number.isFinite(v[1]));
    }

    // å·¥å…·ï¼šçƒé¢è·ç¦»ï¼ˆç±³ï¼‰
    function haversineMeters(a, b) {
        const R = 6371000;
        const dLat = (b[0]-a[0]) * Math.PI/180;
        const dLon = (b[1]-a[1]) * Math.PI/180;
        const lat1 = a[0] * Math.PI/180;
        const lat2 = b[0] * Math.PI/180;
        const h = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
        return 2 * R * Math.asin(Math.sqrt(h));
    }

    // å·¥å…·ï¼šbearing åº¦
    function bearingDeg(a, b) {
        const Ï†1 = a[0]*Math.PI/180, Ï†2 = b[0]*Math.PI/180, Î»1 = a[1]*Math.PI/180, Î»2 = b[1]*Math.PI/180;
        const y = Math.sin(Î»2-Î»1) * Math.cos(Ï†2);
        const x = Math.cos(Ï†1)*Math.cos(Ï†2)*Math.cos(Î»2-Î»1) + Math.sin(Ï†1)*Math.sin(Ï†2);
        let deg = Math.atan2(y, x) * 180/Math.PI;
        return (deg + 360) % 360;
    }

    // å·¥å…·ï¼šæœå‘ä¸è·ç¦»å¾—åˆ°ç»ˆç‚¹
    function destinationPoint(start, brgDeg, distMeters) {
        const R = 6371000;
        const Î´ = distMeters / R;
        const Î¸ = brgDeg * Math.PI/180;
        const Ï†1 = start[0]*Math.PI/180, Î»1 = start[1]*Math.PI/180;
        const sinÏ†1 = Math.sin(Ï†1), cosÏ†1 = Math.cos(Ï†1);
        const sinÎ´ = Math.sin(Î´), cosÎ´ = Math.cos(Î´);
        const sinÏ†2 = sinÏ†1*cosÎ´ + cosÏ†1*sinÎ´*Math.cos(Î¸);
        const Ï†2 = Math.asin(sinÏ†2);
        const y = Math.sin(Î¸)*sinÎ´*cosÏ†1;
        const x = cosÎ´ - sinÏ†1*sinÏ†2;
        const Î»2 = Î»1 + Math.atan2(y, x);
        return [Ï†2*180/Math.PI, ((Î»2*180/Math.PI + 540) % 360) - 180];
    }

    // æ’å€¼ï¼šç»™å®šè·ç¦»ï¼Œè¿”å› [lat, lon]
    function interpolateAtDistance(d) {
        if (trackLatLngs.length === 0) return null;
        if (d <= 0) return trackLatLngs[0];
        if (d >= totalDist) return trackLatLngs[trackLatLngs.length - 1];

        let lo = 0, hi = cumDist.length - 1;
        while (lo < hi) {
            const mid = (lo + hi) >> 1;
            if (cumDist[mid] < d) lo = mid + 1; else hi = mid;
        }
        const i = Math.max(1, lo);
        const d0 = cumDist[i - 1], d1 = cumDist[i];
        const t = (d - d0) / (d1 - d0);
        const p0 = trackLatLngs[i - 1], p1 = trackLatLngs[i];
        return [p0[0] + (p1[0]-p0[0]) * t, p0[1] + (p1[1]-p0[1]) * t];
    }

    // å½“å‰å‰è¿›æ–¹å‘ç”¨äºâ€œé å‰å¯è§†â€
    function currentBearing(pos) {
        if (trackLatLngs.length < 2) return 0;
        let lo = 0, hi = cumDist.length - 1;
        while (lo < hi) {
            const mid = (lo + hi) >> 1;
            if (cumDist[mid] < currentDist) lo = mid + 1; else hi = mid;
        }
        const i = Math.max(1, lo);
        const p1 = trackLatLngs[Math.min(i, trackLatLngs.length - 1)];
        const ref = (currentDist >= totalDist) ? trackLatLngs[trackLatLngs.length - 2] : pos;
        return bearingDeg(ref, p1);
    }

    // UI æ›´æ–°
    function updateProgressUI() {
        const ratio = totalDist ? currentDist / totalDist : 0;
        $("#progress").val(ratio);
        $("#pct").text((ratio*100).toFixed(1) + "%");

        const unit = $("#unitSelector").val();
        const factor = (unit === 'km') ? 1000 : 1;
        const totalText = (totalDist / factor).toFixed(2);
        const currentText = (currentDist / factor).toFixed(2);
        $("#dist").text(`${currentText} / ${totalText} ${unit}`);
    }

    // ç›¸æœºè·Ÿéš
    function applyFollowCamera(pos) {
        const mode = $("#followMode").val();
        if (mode === "off") return;

        const brg = currentBearing(pos);
        const pitchAngle = parseFloat($("#pitchAngle").val());

        let target = pos;
        if (mode === "lead") {
            const lead = Math.max(50, Math.min(20000, parseFloat($("#leadMeters").val() || "1200")));
            target = destinationPoint(pos, brg, lead);
        }

        const cameraHeight = parseFloat($("#cameraHeight").val());
        const cameraDistance = cameraHeight / Math.tan(Cesium.Math.toRadians(-pitchAngle));
        const cameraPos = destinationPoint(pos, (brg + 180) % 360, cameraDistance);

        viewer.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(cameraPos[1], cameraPos[0], cameraHeight),
            orientation: {
                heading: Cesium.Math.toRadians(brg),
                pitch: Cesium.Math.toRadians(pitchAngle),
                roll: 0.0
            }
        });
    }

    // è®¾ç½®/é‡ç½®è½¨è¿¹
    function setupTrack(latlngs) {
        trackLatLngs = latlngs.slice();
        cumDist = [0]; totalDist = 0;

        for (let i = 1; i < trackLatLngs.length; i++) {
            totalDist += haversineMeters(trackLatLngs[i-1], trackLatLngs[i]);
            cumDist.push(totalDist);
        }

        // bounds
        let minLat = 90, minLon = 180, maxLat = -90, maxLon = -180;
        trackLatLngs.forEach(([lat, lon]) => {
            if (lat < minLat) minLat = lat;
            if (lon < minLon) minLon = lon;
            if (lat > maxLat) maxLat = lat;
            if (lon > maxLon) maxLon = lon;
        });
        bounds = { minLat, minLon, maxLat, maxLon };

        // æ¸…ç†æ—§å®ä½“
        viewer.entities.removeAll();

        // æ–°å»ºå…¨è½¨è¿¹ï¼ˆç°ï¼‰
        fullLineEntity = viewer.entities.add({
            polyline: {
                positions: Cesium.Cartesian3.fromDegreesArray(trackLatLngs.flatMap(([lat, lon]) => [lon, lat])),
                width: 3,
                material: Cesium.Color.fromCssColorString("#888").withAlpha(0.7),
                clampToGround: false
            }
        });

        // å·²èµ°ï¼ˆçº¢ï¼‰
        walkedLineEntity = viewer.entities.add({
            polyline: {
                positions: new Cesium.CallbackProperty(() => {
                    const walkedPoints = [];
                    for (let i = 0; i < trackLatLngs.length; i++) {
                        if (cumDist[i] <= currentDist) {
                            walkedPoints.push(trackLatLngs[i]);
                        } else {
                            walkedPoints.push(interpolateAtDistance(currentDist));
                            break;
                        }
                    }
                    return Cesium.Cartesian3.fromDegreesArray(walkedPoints.flatMap(([lat, lon]) => [lon, lat]));
                }, false),
                width: 4,
                material: Cesium.Color.RED.withAlpha(0.95),
                clampToGround: false
            }
        });

        // æ ‡è®°
        markerEntity = viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(trackLatLngs[0][1], trackLatLngs[0][0], 0),
            billboard: {
                image: new Cesium.CallbackProperty(() => createBillboardImage(markerText, customMarkerUrl), false),
                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                disableDepthTestDistance: 1000
            }
        });

        // è·ç¦»æ ‡è®°ï¼Œæ˜¾ç¤ºå·²èµ°è·ç¦»å’Œå‰©ä½™è·ç¦»
        distanceLabelEntity = viewer.entities.add({
            position: new Cesium.CallbackProperty(() => {
                const pos = interpolateAtDistance(currentDist);
                if (!pos) return Cesium.Cartesian3.ZERO;

                const brg = currentBearing(pos);
                // æ ‡ç­¾ä½ç½®åœ¨å½“å‰ç‚¹å‰æ–¹ 250 ç±³å¤„
                const labelPos = destinationPoint(pos, brg, 250);
                return Cesium.Cartesian3.fromDegrees(labelPos[1], labelPos[0], 0);
            }, false),
            label: {
                text: new Cesium.CallbackProperty(() => {
                    const unit = $("#unitSelector").val();
                    const factor = (unit === 'km') ? 1000 : 1;
                    const remaining = totalDist - currentDist;
                    const current = currentDist;

                    const currentText = `å·²èµ°: ${(current / factor).toFixed(2)} ${unit}`;
                    const remainingText = `å‰©ä½™: ${(remaining / factor).toFixed(2)} ${unit}`;
                    return `${currentText}\n${remainingText}`;
                }, false),
                font: '14pt sans-serif',
                fillColor: Cesium.Color.BLACK,
                style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                outlineColor: Cesium.Color.WHITE,
                outlineWidth: 2.0,
                showBackground: true,
                backgroundColor: Cesium.Color.fromCssColorString("#fff").withAlpha(0.0),
                backgroundPadding: new Cesium.Cartesian2(8, 4),
                horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                disableDepthTestDistance: 10000 // ç¡®ä¿æ ‡ç­¾ä¸è¢«åœ°çƒé®æŒ¡
            }
        });

        currentDist = 0; lastTs = null;
        updateProgressUI();

        $("#play,#stop,#fit,#progress").prop("disabled", trackLatLngs.length < 2);
        $("#pause").prop("disabled", true);
    }

    // åŠ¨ç”»å¸§
    function tick(ts) {
        if (!playing) return;
        if (lastTs == null) lastTs = ts;
        const deltaSec = (ts - lastTs) / 1000;
        lastTs = ts;

        const base = parseFloat($("#mps").val());
        const factor = parseFloat($("#speed").val());
        currentDist += base * factor * deltaSec;

        if (currentDist >= totalDist) {
            currentDist = totalDist;
            playing = false;
        }

        const pos = interpolateAtDistance(currentDist);
        if (pos) {
            markerEntity.position = Cesium.Cartesian3.fromDegrees(pos[1], pos[0], 0);
            applyFollowCamera(pos);
        }
        updateProgressUI();

        if (playing) animReq = requestAnimationFrame(tick);
        else {
            cancelAnimationFrame(animReq);
            animReq = null;
            $("#play").prop("disabled", false).text("é‡æ’­").addClass("primary");
            $("#pause").prop("disabled", true);
        }
    }

    // é€‚é…è§†åŸŸåˆ°è½¨è¿¹
    function fitToBounds() {
        if (!bounds) return;
        const rect = Cesium.Rectangle.fromDegrees(bounds.minLon, bounds.minLat, bounds.maxLon, bounds.maxLat);
        viewer.camera.flyTo({ destination: rect });
    }

    // æ ¹æ®é€‰æ‹©çš„æ¯”ä¾‹è°ƒæ•´åœ°å›¾å®¹å™¨å°ºå¯¸
    function handleAspectRatioChange() {
        const ratio = $("#aspectRatio").val();
        const container = $("#cesiumContainer");
        const windowWidth = $(window).width();
        const windowHeight = $(window).height();

        if (ratio === "default") {
            container.css({ width: "100%", height: "100%" });
        } else {
            const [ratioWidth, ratioHeight] = ratio.split(":").map(Number);
            const windowRatio = windowWidth / windowHeight;
            const targetRatio = ratioWidth / ratioHeight;

            let newWidth, newHeight;
            if (windowRatio > targetRatio) {
                newHeight = windowHeight;
                newWidth = newHeight * targetRatio;
            } else {
                newWidth = windowWidth;
                newHeight = newWidth / targetRatio;
            }
            container.css({ width: newWidth + "px", height: newHeight + "px" });
        }
        viewer.resize();
    }

    // äº‹ä»¶ç»‘å®š
    $(function(){
        viewer.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(139.0, 35.0, 2_000_000)
        });

        handleAspectRatioChange();
        $(window).on("resize", handleAspectRatioChange);
        $("#aspectRatio").on("change", handleAspectRatioChange);

        $("#file").on("change", function(e){
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(evt){
                const gpxText = evt.target.result;
                const latlngs = parseGPXToLatLngs(gpxText);
                if (!latlngs || latlngs.length < 2) {
                    alert("æœªè§£æåˆ°æœ‰æ•ˆè½¨è¿¹ç‚¹ï¼ˆtrkpt/rteptï¼‰");
                    return;
                }
                setupTrack(latlngs);
                fitToBounds();
                $("#fit").prop("disabled", false);
            };
            reader.readAsText(file);
        });

        $("#play").on("click", function(){
            if (totalDist <= 0) return;
            playing = true; lastTs = null;
            $("#pause").prop("disabled", false);
            $(this).removeClass("primary").text("æ’­æ”¾");
            animReq = requestAnimationFrame(tick);
        });

        $("#pause").on("click", function(){
            playing = false;
            cancelAnimationFrame(animReq);
            $(this).prop("disabled", true);
            $("#play").prop("disabled", false).addClass("primary").text("ç»§ç»­");
        });

        $("#stop").on("click", function(){
            playing = false;
            cancelAnimationFrame(animReq);
            currentDist = 0;
            updateProgressUI();
            if (markerEntity && trackLatLngs.length) {
                const p = trackLatLngs[0];
                markerEntity.position = Cesium.Cartesian3.fromDegrees(p[1], p[0], 0);
            }
            $("#pause").prop("disabled", true);
            $("#play").prop("disabled", false).addClass("primary").text("æ’­æ”¾");
        });

        $("#fit").on("click", fitToBounds);

        $("#progress").on("input", function(){
            if (totalDist <= 0) return;
            const ratio = parseFloat($(this).val());
            currentDist = Math.max(0, Math.min(1, ratio)) * totalDist;
            const pos = interpolateAtDistance(currentDist);
            if (pos && markerEntity) {
                markerEntity.position = Cesium.Cartesian3.fromDegrees(pos[1], pos[0], 0);
                applyFollowCamera(pos);
            }
            updateProgressUI();
        });

        $("#followMode").on("change", function(){
            const mode = $(this).val();
            $("#leadWrap").css("display", mode === "lead" ? "inline-flex" : "none");
        }).trigger("change");

        // å¤„ç†å›¾æ ‡æ–‡ä»¶ä¸Šä¼ 
        $("#markerIcon").on("change", function(e) {
            const file = e.target.files[0];
            if (!file) {
                customMarkerUrl = null;
                return;
            }
            const reader = new FileReader();
            reader.onload = function(evt) {
                customMarkerUrl = evt.target.result;
                markerText = ''; // æ¸…é™¤æ–‡å­—ï¼Œä¼˜å…ˆæ˜¾ç¤ºå›¾ç‰‡
                $("#emojiSelector").val('');
            };
            reader.readAsDataURL(file);
        });

        // å¤„ç†äº¤é€šå·¥å…·é€‰æ‹©
        $("#emojiSelector").on("change", function() {
            markerText = $(this).val();
            customMarkerUrl = null; // æ¸…é™¤å›¾ç‰‡ï¼Œä¼˜å…ˆæ˜¾ç¤ºæ–‡å­—
            $("#markerIcon").val('');
        });

        // å¤„ç†ç›¸æœºé«˜åº¦è°ƒæ•´
        $("#cameraHeight").on("input", function() {
            $("#heightLabel").text($(this).val() + " m");
        });

        // å¤„ç†ç›¸æœºä»°è§’è°ƒæ•´
        $("#pitchAngle").on("input", function() {
            $("#pitchLabel").text($(this).val() + "Â°");
        });

        // å¤„ç†é«˜ç¨‹æ‹‰ä¼¸
        $("#exaggeration").on("input", function() {
            const val = parseFloat($(this).val());
            viewer.scene.globe.terrainExaggeration = val;
            $("#exaggerationLabel").text(val + "x");
        });

        // å¤„ç†å•ä½é€‰æ‹©
        $("#unitSelector").on("change", updateProgressUI);

        // å¤„ç†æ ‡ç­¾æ˜¾ç¤º/éšè—
        $("#showLabel").on("change", function() {
            if (distanceLabelEntity) {
                distanceLabelEntity.show = this.checked;
            }
        });

        // --- NEW: Add event handler for the toggle button ---
        $("#toggle-controls-btn").on("click", function() {
            const controls = $("#controls");
            const isHidden = controls.css("display") === "none";
            controls.toggle(); // Toggles the display
            if (isHidden) {
                $(this).text("éšè—");
                $(this).css({ left: '', right: '10px' });
            } else {
                $(this).text("æ˜¾ç¤º");
                $(this).css({ left: '10px', right: '' });
            }
        });
    });
</script>
</body>
</html>